---
title: "Analyses spatiales avec R et mapme.biodiversity : application aux mangroves et forêts protégées sénégalaises"
author: "Lenaïg Moign, Florent Bédécarrats"
format:
  html:
    output-file: "index"
    output-ext: "html"
    output-dir: "docs"
    toc: true
    toc-depth: 3
    embed-resources: true
    number-sections: true
editor: visual
execute:
  warning: false
  error: false
editor_options: 
  chunk_output_type: console
---

## Objectifs de la formation

Faire des analyses spatiales avec R et notamment :

1. Prendre conscience du potentiel des données en open data
2. Comprendre la manière dont sont structurées les données spatio-temporelles
3. Entretenir un recul critique sur les données
4. Comprendre dans quels cas l'utilisation de R est opportune
5. Se familiariser avec la logique et les méthodes de traitement sous R
6. Identifier comment approfondir sa maîtrise si opportun


> **Discussion** : Avez-vous une expérience avec R ? Partagez-vous ces objectifs ? Quels sont vos commentaires à leur égard ? 

## Fonctionnement de RStudio

Nous allons maintenant lancer et prendre en main le logiciel. 

Vous avez téléchargé votre fichier zippé "data". Dézipper le dans un dossier de travail. Ouvrez R studio. Allez dans "file/new project/existing directory" et vous sélectionnez le dossier contenant votre dossier data. 

### Interface

Elle comporte quatre fenêtres :

![Fenêtre de l'interface utilisateur R studio (Source : ourednik.info)](Figures/R_interface_colored.png)

A)  **Source** : pour éditer les fichiers scripts (R et autres langages)

B)  **Console** : où s'exécute le code et où on peut directement taper des commandes

C)  **Environnement** : qui rassemble des fonctionnalités pour suivre le fonctionnement de R

D)  **Explorateur** : vue sur les fichiers, libraries et rendus

### Règles de code

Lorsque vous travaillez sur RStudio, il est recommandé de suivre certaines règles de code pour maintenir un code clair, lisible et cohérent.

Voici quelques règles générales à prendre en compte :

- Objets 

- Assignation 

- Opérations

- Opérateur pipe 

- Résultats

- Documents 

Dans quels cas on utilise R ? Discussion

### Raccourcis clavier

Il existe différents raccourcis clavier pour faciliter la mise en forme et l'exécution du code

![Raccourcis clavier pratiques sur R studio](Figures/Raccourcis_clavier.JPG)

### Opérateurs

R Studio est un environnement de développement intégré (IDE) spécialement conçu pour le langage de programmation R.

Lorsque vous travaillez dans R Studio, vous pouvez utiliser différents types d'opérateurs pour effectuer des opérations mathématiques, logiques et de manipulation de données. 

Si vous souhaitez explorer les fonctionnalités de R :

## Pour aller plus loin

Exemple d'intentation :

```{r identation}
#| eval: false 

# Pas bien : difficile a lire
if (a>0){
b <- a^2
if (b>4){
c <- log(b)
}else{
c <- exp(b)
}
}else{
b <- -a^2 + 3
c <- NULL
}

# Bien : lisible (il suffit de faire CTRL+I)
if (a > 0) {
  b <- a^2
  if (b > 4) {
    c <- log(b)
  } else {
    c <- exp(b)
  }
} else {
  b <- -a^2 + 3
  c <- NULL
}

```

Exemple d'opérateurs :

-   Opérateurs arithmétiques

```{r arithmetique}

#| eval: false 

a <- 10
b <- 5

addition <- a + b  # Addition
soustraction <- a - b  # Soustraction
multiplication <- a * b  # Multiplication
division <- a / b  # Division
modulo <- a %% b  # Modulo
exponentiation <- a ^ b  # Exponentiation
division_entiere <- a %/% b  # Division entière

```

-   Opérateurs de comparaison

```{r comparaison}
#| eval: false 

x <- 10
y <- 5

egalite <- x == y  # Égalité
difference <- x != y  # Différence
inferieur <- x < y  # Inférieur à
inferieur_egal <- x <= y  # Inférieur ou égal à
superieur <- x > y  # Supérieur à
superieur_egal <- x >= y  # Supérieur ou égal à

```

-   Opérateurs logiques

```{r logiques}
#| eval: false 

p <- TRUE
q <- FALSE

et_logique <- p & q  # ET logique
ou_logique <- p | q  # OU logique
non_logique <- !p  # NON logique

```

-   Opérateurs d'affectation

```{r affectation}
#| eval: false 

x <- 10  # Affectation simple
y <- c(1, 2, 3)  # Affectation d'un vecteur

```

-   Opérateurs de concaténation

```{r concatenation}
#| eval: false 

prenom <- "John"
nom <- "Doe"

concatenation <- paste(prenom, nom)  # Concaténation de chaînes de caractères

```

-   Opérateurs d'indexation

```{r index}
#| eval: false 

vecteur <- c(1, 2, 3, 4, 5)
matrice <- matrix(1:9, nrow = 3)
liste <- list(1, "a", TRUE)

element1 <- vecteur[2]  # Indexation d'un élément dans un vecteur
sous_vecteur <- vecteur[2:4]  # Indexation d'un sous-vecteur
element_matrice <- matrice[2, 3]  # Indexation d'un élément dans une matrice
sous_matrice <- matrice[1:2, 2:3]  # Indexation d'une sous-matrice
element_liste <- liste[[2]]  # Indexation d'un élément dans une liste

```

## Installation et chargement des librairies R

Le moyen le plus simple d'installer une librairie est d'utiliser le menu "packages" dans le panneau d'exploration (en bas à droite).

```{r install_librairies}
# INSTALLATION DES LIBRAIRIES R 

librairies_req <- c("tidyverse",# Une série de packages pour faciliter la manipulation de données
                    "readxl", # Pour lire les fichiers excel (Carvalho et al. 2018)
                    "writexl",# Pour écrire des fichiers excel 
                    "gt",# Pour produire de jolis tableaux
                    "sf", # Pour faciliter la manipulation de données géographiques
                    "geodata", # Pour télécharger simplement les frontières administratives
                    "tmap",# Pour produire de jolies cartes 
                    "wdpar", # Pour télécharger la base d'aires protégées WDPA
                    "remotes",
                    "progressr") # Pour importer et analyser des indicateurs de biodiversité

manquantes <- !(librairies_req %in% installed.packages())
if (any(manquantes)) install.packages(librairies_req[manquantes])

# CHARGEMENT DES LIBRAIRIES NÉCESSAIRES AUX PREMIERS TRAVAUX

library(tidyverse)
library(geodata)
library(sf)
library(tmap)
library(wdpar)
library(gt)
library(dplyr)
library(lubridate)
library(tmap)

mapme_version <- installed.packages() %>%
  data.frame() %>%
  filter(Package == "mapme.biodiversity") %>%
  pluck("Built") %>%
  ifelse(length(.) == 0, "", .)

if (!("mapme.biodiversity" %in% installed.packages()) & mapme_version != "4.2.3") {
  remotes::install_github(
    "https://github.com/mapme-initiative/mapme.biodiversity.git")
  }

library(mapme.biodiversity)

```

## Chargement des données sur les aires protégées

L'initiative WDPA (World Database on Protected Areas) est un projet international visant à recueillir, à gérer et à diffuser des informations sur les aires protégées à travers le monde.

Cette initiative est coordonnée par l'UICN (Union internationale pour la conservation de la nature) et est soutenue par plusieurs partenaires et organisations internationales.

La base de données WDPA constitue une source d'information complète sur les aires protégées, y compris les parcs nationaux, les réserves naturelles, les sites du patrimoine mondial, les aires marines protégées et d'autres types d'espaces préservés.

Elle rassemble des données sur les limites géographiques, les statuts juridiques, les catégories de gestion, la taille, la biodiversité, les écosystèmes et d'autres caractéristiques des aires protégées.

```{r import_wdpa}
# TÉLÉCHARGEMENT DES DONNÉES DU WDPA AVEC LE PACKAGE WDPAR

# On commence par importer les données libres d'accès, on les enregistre sur 
# le disque local  

if (!file.exists("data/WDPA/WDPA_Jun2023_SEN-shapefile.zip")) {
  WDPA_Senegal <- wdpa_fetch("Senegal", wait = TRUE, 
                          download_dir = "data/WDPA") 
} else {
  # Enregistrement serveur local 
  WDPA_Senegal <- wdpa_read("data/WDPA/WDPA_Jun2023_SEN-shapefile.zip") 
}

```

## Chargement des contours administratifs

```{r import_contour_sen}
# TÉLÉCHARGEMENT DES CONTOURS ADMINISTRATIFS AVEC LE PACKAGE GEODATA

# On commence par importer les données libre d'accès, on les enregistre sur 
# le disque local et on les convertit au format standardisé sf 

if (!file.exists("data/GADM/gadm41_SEN_0_pk.rds")) {
contour_sen <- gadm(country = "Senegal", resolution = 1, level = 0, 
                     path = "data/GADM") %>%  
  st_as_sf() 
  
} else {
  # Enregistrement serveur local 
  contour_sen <- read_rds("data/GADM/gadm41_SEN_0_pk.rds")
}

```

## Exploration des données disponibles sur les aires protégées

### Caractéristiques spatiales

On charge de l'information géographique, il est important de connaître les caractéristiques de base des objets à savoir :

Quels types de géométrie ? Quel système de projection ?

```{r geometrie}
# CONNAÎTRE LES GÉOMÉTRIES DE LA COUCHE (POINTS, LIGNES, POLYGONES) 

# On crée une colonne pour connaître la géométrie de chaque observation (mutate) 
# On trie les données en fonction de leur géométrie (group_by) 
# On résume l'effectif total pour chaque catégorie de géométrie (summarise). 

WDPA_Senegal %>%
  mutate(geom_type = st_geometry_type(.)) %>%  
  group_by(geom_type) %>%  
  summarise(n = n())  %>%
  st_drop_geometry() %>%
  gt() # Cette fonction sert à produire un affichage "propre

# CONNAÎTRE LE SYSTÈME DE PROJECTION 

st_crs(WDPA_Senegal)

st_crs(contour_sen) == st_crs(WDPA_Senegal)

```

### Données manquantes

Afin d'avoir un aperçu synthétique des données manquantes, il est possible d'exécuter les commandes suivantes.

Pour rappel, la fonction gt() sert à produire de jolis tableaux. Elle arrive en fin de code, une fois qu'on a synthétisé ce que l'on veut retenir comme variables de notre tableau.

La fonction pivot_long() doit être exécutée avant d'utiliser gt() car le package traite la donnée en format "long" et non en format "large" comme c'est le cas pour le moment dans l'objet WDPA Senegal.

```{r donnees_manquantes}
# CRÉER UN TABLEAU SYNTHÉTIQUE POUR AVOIR UNE VUE GLOBALE DES DONNÉES MANQUANTES

# On supprime tout d'abord la colonne des géométries pour faciliter le traitement
# On résume les données qui nous intéresse à savoir l'effectif total d'aires
# protégées, les catégories IUCN, année de création et gestionnaire
# La fonction pivot_longer permet de passer d'un format large à un format long
# Ce format est nécessaire pour créer des tableaux stylisés avec la fonction gt
# On ajoute un titre et les sources

WDPA_Senegal %>%
  st_drop_geometry() %>% 
  summarise("Nombre total d'aires protégées" = n(),
            "Catégorie IUCN manquante" = sum(IUCN_CAT == "Not Reported"),
            "Année de création manquante" = sum(STATUS_YR == 0),
            "Gestionnaire manquant" = sum(MANG_AUTH == "Not Reported")) %>%
  pivot_longer(cols = everything(),
               names_to = " ",
               values_to = "Nombre d'aires") %>%
  gt() %>%
  tab_header("Valeurs manquantes dans les données WDPA pour le Sénégal") %>%
  tab_source_note("Source : WDPA (juin 2023)")

```

## Produire des cartes synthétiques sur les aires protégées

La table attributaire du WDPA est suffisamment renseignée pour pouvoir produire des cartes thématiques pour mettre en avant une variable de notre jeu de données.

Carte 1. Les différentes catégories d'aires protégées au Sénégal d'après les données satellitaires du WDPA ;

```{r carte_aires_prot}
# PRODUCTION DE CARTES THÉMATIQUES ET ESTHÉTIQUES AVEC LE PACKAGE TMAP

tmap_mode(mode = "view") 

tm_shape(contour_sen) +
  tm_borders() + 
  tm_shape(WDPA_Senegal) + 
  tm_polygons(col = "DESIG", alpha = 0.6, title = "Catégories d'aires 
              protégées au Sénégal",
              id = "NAME", 
              popup.vars = c("Type" = "DESIG", 
                             "Catégorie IUCN" = "IUCN_CAT",
                             "Surface déclarée" = "REP_AREA",
                             "Année du statut" = "STATUS_YR"))

tmap_options(check.and.fix = TRUE)

```

## Acquisition de données environnementales et calcul d'indicateurs

### Le package mapme.biodiversity

Le package "mapme.biodiversity" facilite l'analyse de données statistiques sur les aires protégées partout dans le monde.

Il permet l'**importation d'un nombre important de base de données et le calcul d'indicateurs associés relatifs à la biodiversité** qui peuvent être utilisés pour surveiller et évaluer l'efficacité des efforts de protection.

Pour l'analyse des données géographiques, le package utilise sf pour l'exploitation des données vectorielles et terra pour les données rasters.

```{r}

help(package = "mapme.biodiversity")

```

Le package permet de calculer, via une importation de données provenant de sources open data, des indicateurs, disponibles sur des intervalles de temps réguliers pour environ deux décennies (2020-2020).

Ces indicateurs permettent aux usagers d'analyser des dynamiques spatiales et temporelles relatives aux aires protégées.

Pour connaître les ressources et les indicateurs associés disponibles :

```{r dispo_indicateurs}

names(available_indicators())

# LISTE DES INDICATEURS DISPONIBLES

# active_fire_counts: Calculate active fire counts based on NASA FIRMS
#active_fire_properties: Calculate active fire properties based on NASA FIRMS polygons
# biome: Calculate biomes statistics (TEOW) based on WWF
# drought_indicator: Calculate drought indicator statistics
# ecoregion: Calculate terrestrial ecoregions statistics (TEOW) based on WWF
# landcover: Calculate area of different landcover classes
# mangroves_area: Calculate mangrove extent based on Global Mangrove Watch (GMW)
# population_count: Calculate population count statistics (Worldpop)
# precipitation_chirps: Calculate precipitation statistics based on CHIRPS
# precipitation_wc: Calculate precipitation statistics
# soilproperties: Calculate Zonal Soil Properties
# temperature_max_wc: Calculate maximum temperature statistics
# temperature_min_wc: Calculate minimum temperature statistics based on WorldClim
# traveltime: Calculate accessibility statistics
# treecover_area: Calculate treecover statistics
# treecover_area_and_emissions: Calculate treeloss statistics
# treecoverloss_emissions: Calculate emission statistics
# tri: Calculate Terrain Ruggedness Index (TRI) statistics

```

A la lecture de la liste, l'utilisateur choisit quels sont les indicateurs qui l'intéresse en fonction de ses objectifs d'analyse.

Plus de détails sur les indicateurs (source, unité, limites) sont consultables sur le site : https://mapme-initiative.github.io/mapme.biodiversity/reference/index.html

### Constitution d'un portefeuille

Une fois le choix de ressources et d'indicateurs effectué, il faut d'abord *initier un portefeuille de la biodiversité*. Ce principe de création de portefeuille est un traitement spécifique qu'on applique à un objet spatial sf.

-   NB : Dans notre cas, pour faciliter le traitement, on va d'abord subdiviser notre objet `sf` en géométries de type "polygone" avant d'appliquer la fonction `init_portfolio()`. L'idée est d'avoir des indicateurs pour chaque partie de l'aire protégée. Il suffira ensuite de fusionner ces polygones pour avoir des résultats globaux pour les aires protégées composées de plusieurs polygones .\*

Chaque ligne de l'objet est alors considérée comme un **actif unique dans le portefeuille** pour lequel des indicateurs environnementaux seront calculés plus loin dans la chaîne de traitement. C'est-à-dire que le portefeuille produit des colonnes imbriquées pour chaque observation, car dans bien des cas, on peut avoir plusieurs valeurs (par année) pour une même observation, voire plusieurs variables.

Par exemple, le calcul de l'indicateur précipitations... plusieurs observations par année...

En créant le portefeuille, certaines vérifications préliminaires seront automatiquement effectuées, par exemple que le SRS de l'objet est EPSG:4326, sinon il sera transformé.

Certains paramètres globaux du portefeuille, tels que le répertoire de sortie pour les ensembles de données téléchargés, un répertoire temporaire pour les calculs intermédiaires, peuvent être définis par l'utilisateur pour avoir un contrôle plus précis du flux de travail. Cependant, ces paramètres sont également définis sur des valeurs par défaut sensibles et peuvent donc être omis lors de l'initialisation du portefeuille.

```{r portefeuille}

# EXÉCUTION DE LA FONCTION INIT_PORTFOLIO 

# Avant de créer le portefeuille, on filtre notre couche WDPA 
# L'idée est de ne garder que les données  pertinentes (années renseignées, 
# et géométries de type polygone ou multi-polygone)
# Certaines aires protégées sont composées de plusieurs polygones disjoints  
# On les scinde volontairement pour les traiter séparement 
# Pour une analyse par AP, on pourra agréger les résultats

WDPA_mapme <- WDPA_Senegal %>%
  filter(STATUS_YR != 0) %>%
  filter(st_geometry_type(geometry) != "MULTIPOINT") %>% 
  st_cast("POLYGON")

WDPA_mapme <- init_portfolio(x = WDPA_mapme, 
                                     years = 2000:2020,
                                     outdir = "data/mapme_Senegal",
                                     add_resources = TRUE,
                                     verbose = TRUE)

```

Une fois le portefeuille lancé, on peut récupérer les données de notre intérêt en ligne puis lancer le calcul d'indicateurs pour chaque observation de notre objet sf. Cela peut prendre un peu de temps en fonction du volume de données importées.

### Acquisition des données de couvert forestier avec Global Forest Watch (GFW)

```{r deforestation}

# Données de Global Forest Watch (GFW) sur le couvert forestier

WDPA_mapme <- get_resources(x = WDPA_mapme, 
                            resources = c("gfw_treecover", "gfw_lossyear"))

if (file.exists("WDPA_mapme_foret.rds")) {
  WDPA_mapme <- read_rds("WDPA_mapme_foret.rds")
} else {
  # Calcul d'indicateurs GFW
  progressr::with_progress({ # Ceci sert à avoir une barre de progression
    # Cette commande calcule les indicateurs à partir des ressources téléchargées
    WDPA_mapme <- calc_indicators(WDPA_mapme,
                                  indicators = "treecover_area",
                                  min_cover = 30, min_size = 1)
  })
  
  write_rds(WDPA_mapme, "WDPA_mapme_foret.rds")
}

```

### La surface de mangroves avec Global Mangrove Watch (GMW)

```{r mangrove}

# Données de Global Mangrove Watch (GMW) sur la surface de mangroves 

WDPA_mapme <- get_resources(x = WDPA_mapme,resources = "gmw")


if (file.exists("WDPA_mapme_mangrove.rds")) {
  WDPA_mapme <- read_rds("WDPA_mapme_mangrove.rds")
} else {
  # Calcul des indicateurs GMW
progressr::with_progress({ 
  WDPA_mapme <- calc_indicators(WDPA_mapme,
                                indicators = "mangroves_area")
  })

  write_rds(WDPA_mapme, "WDPA_mapme_mangrove.rds")

}

# ENREGISTREMENT DES DONNÉES GFW + GMW SUR 1 FICHIER RDS

save(WDPA_mapme, file = "data/WDPA_indicators.rds") 

```

## Tri des données pour faciliter l'exploration

### Désimbrication des indicateurs

Une fois que l'indicateur a été calculé individuellement pour tous les "actifs" du portefeuille, les données apparaîssent sous la forme d'une **colonne de liste imbriquée** à l'objet d'origine. Si on a plusieurs indicateurs, on aura plusieurs colonnes avec des listes ayant une, deux ou plusieurs variables.

Cette imbrication n'est pas toujours indispensable. Par exemple, pour les variables calculées ici (*couvert forestier et surface de mangrove*), on ne cherche qu'une valeur par observation. On va donc **désimbriquer** les données à l'aide de la fonction *unnest()*.

On doit aussi se rappeler que les aires protégées sont parfois composées de plusieurs polygones disjoints et que précédemment, pour l'utilisation de mapme.biodiversity, on a calculé chaque indicateur pour chaque polygone séparément. Pour chaque aire protégée, on va donc faire la moyenne de ces indicateurs, pondérée par la surface respective de chaque polygone.

Nous appelerons ce tableau WDPA_terrain :

```{r desimbrication}

# DÉSIMBRICATION DES LISTES D'INDICATEURS 

# On déplie les données des colonnes importées 

WDPA_terrain <- WDPA_mapme %>%
  unnest(c(treecover_area)) %>% 
  unnest(c(mangroves_area)) 

```

On obtient alors un tableau avec un nombre d'observations important pour un même polygone. **Pour un espace donné, plusieurs variables sont mesurées et sur des périodes de temps différentes**. Il faut donc maintenant rendre plus lisibles les données, sélectionner l'information avant de procéder à l'analyse statistique.

### Sélection des variables les plus pertinentes

Nous faisons le choix de ne garder que certaines variables. Ce choix dépend directement de l'analyse statistique que nous voulons faire derrière.

```{r tableau_stats}

# SÉLECTION DES VARIABLES PERTINENTES 

WDPA_stats <- WDPA_terrain %>% 
  select(Nom = ORIG_NAME, 
         Surface = REP_AREA, 
         Aire_marine_terrestre = MARINE, 
         Mangrove_surface = mangrove_extent,
         Annees_mangrove = year,
         Couvert_foret = treecover,
         Annees_f = years,
         Categorie = DESIG,
         Annee_creation = STATUS_YR) 

```

## Exploration des indicateurs environnemtaux sur les aires protégées

Maintenant, il est possible d'explorer ces résultats en vue de les exploiter.

Nous pouvons commencer avec une analyse globale où nous cherchons par exemple à connaître l'état des indicateurs sur une année précise. Quelle est la surface moyenne de forêt et de mangrove en 2020 au sein de chaque aire protégée ?

```{r indicateurs_2020}

# RÉSULTATS SUR UNE ANNÉE (2020)

# On filtre d'abord les résultats à l'aide des opérateurs pour ne garder 
# que l'année 2020, on regroupe ensuite les données par Nom (pour avoir le 
# résultat par aire protégée) puis on calcule la moyenne pour l'ensemble
# des polygones 

WDPA_moyenne_2020 <- WDPA_stats %>% 
  filter(Annees_mangrove == 2020, Annees_f == 2020) %>% 
  group_by(Nom) %>%
  summarize(Moyenne_surface_mangrove = format(mean(Mangrove_surface),
                                              scientific = FALSE),
            Moyenne_couvert_foret = mean(Couvert_foret)) 
  

```

Nous pouvons aussi filter nos recherches sur une aire protégée. L'idéal serait d'avoir une aire protégée où il y a de la forêt et de la mangrove. Au lieu d'appliquer ces conditions sur l'ensemble du jeu de données, afin de gagner du temps, on choisit de se focaliser sur 2019.

```{r liste_foret_mangrove}

# RECHERCHE D'AIRE PROTÉGÉE CONTENANT DE LA MANGROVE ET DE LA FORÊT

WDPA_moyenne_2020 %>% 
  st_drop_geometry() %>% 
  filter(Moyenne_couvert_foret != 0 & Moyenne_surface_mangrove != 0) %>%
  select(Nom) %>% 
  gt()

```

Maintenant qu'on a obtenu la liste des aires protégées ayant de la forêt et de la mangrove, nous pouvons revenir à notre tableau précédent et nous focaliser sur une zone d'intérêt.

Exemple de la Basse-Casamance :

```{r basse_casamance}

# ÉTAT DES INDICATEURS EN BASSE CASAMANCE 

WDPA_Casamance <-  WDPA_stats %>% 
  filter(Nom == "Basse-Casamance") 
  
```

On remarque alors que la *superficie des aires protégées est en km²* alors que les superficies des mangroves et de la forêt sont en Ha, on va donc modifier notre tableau initial pour convertir les Ha en km² et ne plus avoir d'erreur.

Cet exemple confirme **l'importance de lire la documentation** avant d'utiliser des données.

```{r ap_nouvelle_surface}

# CRÉATION D'UNE COLONNE SURFACE EN HA

WDPA_stats <- WDPA_stats %>%
  mutate(Surface_ha = Surface * 100) %>%
  select(-Surface)

```

### Production d'une carte thématique sur le couvert forestier par aire protégée

Nous souhaiterions maintenant créer une carte comme cela a déjà été fait précédemment pour mettre en avant la variable de notre choix dans les aires protégées.

Si nous commençons avec le couvert forestier, il faut d'abord créer un nouvel objet *WDPA_foret* qui synthétise les valeurs par année et par aire protégée.

```{r carte_foret_2019}

# CARTE COUVERT FORESTIER 2020 (VOIR POUR RENOMMER COUVERT_FORET)

# On filtre les données que l'on veut présenter sur la carte, à savoir l'année

WDPA_foret_2020 <- WDPA_stats %>% 
  filter(Annees_f == 2020)

# On utilise les fonctionnalités du package tmap()

tm_shape(contour_sen) +
tm_borders() + 
tm_shape(WDPA_foret_2020) + 
tm_polygons(col = "Couvert_foret", alpha = 0.6, title = "Couvert forestier 
            des aires protégées en 2020 au Sénégal",
              id = "Nom",
              legend.format = list(big.mark = ""),
              popup.vars = c("Catégorie" = "Categorie",
                             "Surface déclarée" = "Surface_ha",
                             "Année de création " = "Annee_creation"))


```

Exemple avec de la mangrove :

```{r carte_mangrove_2019}

# CARTE SURFACE LE MANGROVE DES AIRES PROTEGEES EN 2020 

WDPA_mangrove_2020 <- WDPA_stats %>% 
  filter(Annees_mangrove == 2020)

tm_shape(contour_sen) +
tm_borders() + 
tm_shape(WDPA_mangrove_2020) + 
tm_polygons(col = "Mangrove_surface", alpha = 0.6, title = "Surface de mangrove 
            des aires protégées en 2020 au Sénégal",
            palette = "Greens",
            id = "Nom",
            legend.format = list(big.mark = " "),
            popup.vars = c("Catégorie" = "Categorie",
                             "Surface déclarée" = "Surface_ha",
                             "Année de création" = "Annee_creation")) 


```

Tableau : série temporelle de la mangrove en Basse Casamance

```{r}

WDPA_BC_evolution <- WDPA_Casamance %>%
  mutate(Surface_ha = Surface * 100) %>%
  select(Mangrove_surface, Annees_mangrove, Surface_ha, Categorie, Annee_creation) %>% 
  distinct() 


```

Carte : évolution de la mangrove en BC

```{r}

tm_shape(contour_sen) +
tm_borders() + 
tm_shape(WDPA_BC_evolution) + 
tm_polygons(col = "Mangrove_surface", group = "Annees_mangrove", alpha = 0.6, title = "Evolution de la surface de mangrove en Basse-Casamance de 2007 à 2020",
            palette = "Greens",
            id = "Nom",
            legend.format = list(big.mark = " "),
            popup.vars = c("Catégorie" = "Categorie",
                             "Surface déclarée" = "Surface_ha",
                             "Année de création" = "Annee_creation")) 

```

Piste : utilisation de rasters ?